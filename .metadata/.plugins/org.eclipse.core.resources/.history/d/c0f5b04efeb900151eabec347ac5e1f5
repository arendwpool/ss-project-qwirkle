package models;

import java.util.ArrayList;

import exceptions.InvalidMoveException;

/**
 *De klasse die een speelbord representeerd maakt met een naam en tegels.
 * @author Bob Breemhaar en Arend Pool.
 *
 */
public class Board {
	private	Tile[] [] coordinaten;
	private static final int DIM = 179;
	private boolean initialMove;

	/*
	 * Constructor van het Board
	 */
	public Board(){	
		reset(); //TODO reset creeëren?
		initialMove = true;
	}
	
	/*
	 * creeërt een kopie van het speelveld
	 */
	public Board deepCopy(){
		coordinaten = new Tile[DIM][DIM];
		for (int x = 0; x < coordinaten.length; x++) {
			for (int y = 0; y < coordinaten.length; y++) {
				coordinaten[x][y] = null;
				}
			}
		return null; //TODO FIX dit LUL
		}
	
	/* 
	 * returns de inhoud van field i.
	 */
	
	
	/*
	 * returns de inhoud verwezen door het paar (x,y) .
	 */
	public Tile getField(int x, int y){
		return coordinaten[x][y];
	}
	
	
	/*
	 * returns true als een verwezen field pair(x,y) leeg is
	 */
	public boolean isEmptyField(int x, int y){
		return (coordinaten[x][y] == null);
	}
	
	//TODO eventueel code verbeteren door de hoeveelheid duplicaatcode te verminderen
	public ArrayList<Tile> tilesOnXAxis(int x, int y){
		boolean leftIsEmpty = false;
		boolean rightIsEmpty = false;
		int xOrig = x;
		ArrayList<Tile> xAxis = new ArrayList<Tile>();
		while(leftIsEmpty == false){
			x--;
			if(isEmptyField(x,y) == false){
				xAxis.add(coordinaten[x][y]);
			}else{
				break; 
			}
		}
		x = xOrig;
		while(rightIsEmpty == false){
			x++;
			if(isEmptyField(x,y) == false){
				xAxis.add(coordinaten[x][y]);
			}else{
				break; 
			}
		}
		return xAxis;
	}
	
	public ArrayList<Tile> tilesOnYAxis(int x, int y){
		boolean upperIsEmpty = false;
		boolean lowerIsEmpty = false;
		int yOrig = y;
		ArrayList<Tile> yAxis = new ArrayList<Tile>();
		while(lowerIsEmpty == false){
			y--;
			if(isEmptyField(x,y) == false){
				yAxis.add(coordinaten[x][y]);
			}else{
				break; 
			}
		}
		y = yOrig;
		while(upperIsEmpty == false){
			y++;
			if(isEmptyField(x,y) == false){
				yAxis.add(coordinaten[x][y]);
			}else{
				break; 
			}
		}
		return yAxis;
	}
	public boolean isValidMove(int x, int y, Tile tile){
		//Tile controlTile = ;
		//TODO implementatie weizigen zodat deze compitabel is met arraylists
		while (isEmptyOnXNeg = false){
			x--;	//een stap naar links
			if (isEmptyField(x, y) == false){
				xAxis.add(coordinaten[x][y]);
			}else{
				x = xOrig;
			}
		}
		
		/*if(isEmptyField(x, y) == false){
			return false;
		}else if(initialMove == true && x == 90 && y == 90){
			initialMove = false;
			return true;
		
		}else if((x != 90 && y == 90) || (x == 90 && y != 90) || (x != 90 && y != 90)){
			if(compareSymbool(tileA, tileB) == true && compareColor(tileA, tileB) == true){
				return false;
			}else if(compareSymbool(tileA, tileB) == false && compareColor(tileA, tileB) == false){
				return false;
			}else{
				return true;
			}
		}else{
			return false;
		}//TODO Meer invalid shit vinden*/
	}
	
	public boolean compareSymbool(Tile tileA, Tile tileB){
		return(tileA.getSymbol() == tileB.getSymbol());
		
	}
	
	public boolean compareColor(Tile tileA, Tile tileB){
		return(tileA.getColor() == tileB.getColor());
	}
	
	/* 
	 * Moet de Move van de player verwerken.
	 */
	public void processMove(int x, int y, Tile tile) throws InvalidMoveException{
		if(isValidMove(x, y, tile, new Tile("kleur", "symbool"))){
			//TODO veranderen zodat hij checkt of de move valid is
			coordinaten[x][y] = tile;
		}else{
			throw new InvalidMoveException();
		}
		//TODO aanpassen op een overzichtelijke manier: welke tile wordt gezet en welke is ter controle
	}
	
	public void reset() {
		for (int x = 0; x < DIM*DIM; x++) {
			for (int y = 0; y < DIM*DIM; y++) {
				coordinaten[x][y] = null;
			}
		}
	}

}
