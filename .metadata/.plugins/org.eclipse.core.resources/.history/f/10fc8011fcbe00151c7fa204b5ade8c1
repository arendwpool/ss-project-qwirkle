package utils;

import java.awt.Point;
import java.util.ArrayList;

import exceptions.InvalidMoveException;
import models.Board;
import models.Player;
import models.Tile;

public class ValidateMoveUtil {

	/**
	 * Geeft aan of een speler heeft geruilt in de plaats van een zet maken.
	 */
	private static boolean hasTraded = false;
	
	/**
	 * Bepaalt of het de eerste move van het spel iets of niet.
	 */
	public static boolean initialMove = true;
	
	/**
	 * Geef een set met de tegels die de betreffende speler heeft neergelegd.
	 */
	private static ArrayList<Tile> lastSet;
	

	/**
	 * Verwijderd alle laatst gezette tegels van een speler.
	 * @throws InvalidMoveException 
	 */
	public static void finishMove(Player player) throws InvalidMoveException {
		if(getLastMoves().size() != 0 || hasTraded == true){
			generateScore(player);
			board.clearLastMoves();
			hasTraded = false;
			nextPlayer();
		}else{
			throw new InvalidMoveException();
		}
	}

	
	/**
	 * genereer de score van een bepaalde move en stuurt deze door aan de methode addScore. Hiervoor
	 * wordt eerst voor elke tegel die een speler heeft neergelegd alle tegels in een rij op de x-as
	 * en alle tegels op een rij op de y-as in lijsten opgeslagen. Vervolgens worden deze lijsten
	 * vergeleken met de lijst van tegels die als laatst zijn neergelegd. De tegels die als laatst
	 * zijn neergelegd in een rij blijven over. Als dit meer dan 1 element is, moeten de punten van
	 * deze rij maar één keer opgeteld worden, en niet het aantal keer dat een gelegde tegel in de
	 * rij voorkomt. Als een rij een lengte van zes heeft wordt er een bonus toegevoegd. Nadat de 
	 * score is berekend wordt deze aan de speler toegevoegd.
	 * @param player
	 */
	public static void generateScore(Player player) {
		Point point = null;
		boolean retainMultipleX = false;
		boolean retainMultipleY = false;
		ArrayList<Tile> row = null;
		ArrayList<Tile> column = null;
		int score = 0;
		for (Tile tile : board.getLastMoves()) {
			point = tile.getLocation();
			int x = (int) point.getX();
			int y = (int) point.getY();
			row = board.tilesOnXAxis(x, y);
			column = board.tilesOnYAxis(x, y);
			ArrayList<Tile> commonX = deleteCommon(row, board.getLastMoves());
			ArrayList<Tile> commonY = deleteCommon(column, board.getLastMoves());
			retainMultipleX = commonX.size() > 1;
			retainMultipleY = commonY.size() > 1;
			if (retainMultipleX == false) {
				score += column.size();
			} else if (retainMultipleY == false) {
				score += row.size();
			}
		}
		if (retainMultipleX == true) {
			score += row.size();
		} else if (retainMultipleY == true) {
			score += column.size();
		}
		player.addScore(score);
	}
	
	public static ArrayList<Tile> deleteCommon(ArrayList<Tile> listToKeep, ArrayList<Tile> listToRemove) {
		ArrayList<Tile> copy = new ArrayList<Tile>(listToKeep);
		copy.removeAll(listToRemove);
		listToKeep.removeAll(copy);
		return listToKeep;
	}
	/**
	 * Controleert of de aangelegde stenen wel volgens de spelregels mogen.
	 */
	//TODO analyzeren: nadat locatie is toegevoegd aan tile, is dit te verbeteren?
	public static boolean isValidMove(int x, int y, Tile tile) {
		Board board = deepCopy();
		board.setTile(x, y, tile);
		ArrayList<Tile> xAxis = tilesOnXAxis(x, y);
		ArrayList<Tile> yAxis = tilesOnYAxis(x, y);
		if (isEmptyField(x, y) == false) {
			return false;
		} else if (xAxis.size() > 6 || yAxis.size() > 6) {
			return false;
		} else if (initialMove == true) { //In Controller x en y 90,90 maken, bij elke eerste zet.
			return true;
		} else if (initialMove == false && xAxis.size() == 1 && yAxis.size() == 1) {
			return false;
		} else {
			for (Tile tileToCompare : xAxis) {
				Tile tileOrig = tileToCompare;
				xAxis.remove(tile);
				for (Tile tileToCompareWith : xAxis) {
					if (compareColor(tileToCompareWith, tileOrig) == true &&
									compareSymbol(tileToCompareWith, tileOrig) == true) {
						return false;
					} else if (compareColor(tileToCompareWith, tileOrig) == true 
									|| compareSymbol(tileToCompareWith, tileOrig) == true) {
						return true;
					} else {
						return false;
					}
				}
			}
		}
		return false; //TODO oplossing voor nu
	}

	/**
	 * Moet de Move van de player verwerken.
	 * @param x
	 * @param y
	 * @param tile
	 */
	public static void processMove(int x, int y, Tile tile) throws InvalidMoveException {
		if (isValidMove(x, y, tile) && (sharedLine(tile, tilesOnYAxis(x, y)) 
						|| sharedLine(tile, tilesOnXAxis(x, y)))) {
			setTile(x, y, tile);
			initialMove = false;
			rememberMove(tile);
		} else {
			rememberMove(null);
			throw new InvalidMoveException();
		}
		//TODO in zijn geheel opnieuw implementeren
	}
	
	/**
	 * Onthoud de laatste move die een speler gedaan heeft.
	 * @param tile
	 */
	public static void rememberMove(Tile tile) {
		lastSet.add(tile);
	}

	
	/**
	 * leegt de set met de laaste moves van de speler.
	 */
	public static void clearLastMoves() {
		lastSet.clear();
	}
	/**
	 * Weergeeft de lijst met de laastse moves.
	 * @return lastSet
	 */
	public static ArrayList<Tile> getLastMoves() {
		return lastSet;
	}
}
